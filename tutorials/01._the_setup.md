# The setup

In the [infrastructure](../infrastructure/) folder, you will find the following files:

---

## Current files

[main.tf](../infrastructure/main.tf) - The main file that contains the resources to be provisioned. Usually this is the first file that will run. It would be possible to put all Terraform code in `main.tf`, and some do, but this project has split the code into multiple files for readability.

The `main.tf` file contains the following resources:

- `terraform` block: Contains the required provider and Terraform configurations.
- `provider "azurerm"` block: Contains the Azure provider configuration.
- `azurerm_resource_group`: Creates the resource group in Azure.

[network.tf](../infrastructure/network.tf) - Contains the network resources to be provisioned. 

This file defines the virtual network, subnet, network interface and public IP address. This is standard and required to have a VM running in Azure.

`azurerm_network_security_rule` defines the `whoknows_ssh_rule` which allows SSH traffic on port 22. This has been created in its own block to give readability to the more custom rules that follow below.

`azurerm_network_security_group` defines defines two security rules that open up ports 80 and 443. This is a standard configuration for running a web server which is the goal of this project. 

You can read more about configuring Azure Firewall rules, especially the meaning of the priority numbering [here](https://learn.microsoft.com/en-us/azure/firewall/rule-processing).


[vm.tf](../infrastructure/vm.tf) - Contains the virtual machine resources to be provisioned.

The resource group and network settings are being attached to it. A disk is also being attached to the VM.

The `source_image_reference` block defines which image to pull from the Azure Marketplace.

Password authentication has been disabled and an SSH key is being transferred to the VM.

```hcl
  admin_ssh_key {
    username   = var.admin_username
    public_key = file(var.ssh_public_key)
  }

  disable_password_authentication = true
```

There is a `remote-exec` block which will be discussed in depth in the next section.

[outputs.tf](../infrastructure/outputs.tf) - Contains the outputs to be displayed after running `terraform apply`.

This is just a convenience thing where it prints out the IP address and ssh command to connect to the VM.

[variables.tf](../infrastructure/variables.tf) - Contains the variables to be used in the Terraform code.

---

## `remote-exec`

In the `vm.tf` file, there is a `remote-exec` block. This is a provisioner that allows you to run scripts on a remote machine. It looks like this:

```hcl
  provisioner "remote-exec" {
    inline = split("\n", templatefile("${path.module}/inline_commands.sh", {}))

    connection {
      type        = "ssh"
      user        = var.admin_username
      private_key = file(var.ssh_private_key)
      host        = self.public_ip_address
      timeout     = "2m"
    }
  }
```

It breaks down each line in my `inline_commands.sh` file and runs them on the remote machine over SSH.

This is non-standard and is not recommended. Instead a tool like Ansible should be used. 

The [inline_commands.sh](../infrastructure/inline_commands.sh) file updates and upgrades the system, installs Docker and creates a new user etc. 

---

## During init

If you were to run `$ terraform init` at a later step, then Terraform will download the Azure provider plugin.

This wil create the `.terraform` folder which contains a lot of nested folders and at one point contains the provider plugin that targets my system architecture on my local machine.

---

## During plan

If you were to run `$ terraform plan` at a later step, then Terraform will create a plan of what it will do.

`terraform.tfstate` is created. This is a JSON file that contains the state of the infrastructure. It is used to compare the current state of the infrastructure with the desired state. This should not be committed to the repository since it contains sensitive information. But keeping it up to date with everyone provisioning with Terraform is crucial. 

`terraform.tfstate.lock.hcl`: Locks the statefile to prevent concurrent modifications.


[Optional] `planfile`. Created by running `$ terraform plan -out=planfile`. This is a binary file that contains the plan. With a planfile, the apply step will follow the plan in the file instead of creating a new plan.

---

## During apply

Both `terraform.tfstate` and `terraform.tfstate.lock.hcl` are updated during the `$ terraform apply` step.

`terraform.tfstate.backup` is created. This contains a backup of the previous state before is applies the changes.

---

## Next: Running locally

Before you get started you might want to create a `terraform.tfvars` file first. This will be explained in [running Terraform locally](./02._running_terraform_locally.md).
